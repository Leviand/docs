---
title: Testing with Playwright
description: How to set up end-to-end testing for a Vaadin application using Playwright.
order: 100
---

= Testing Vaadin Applications with Playwright

link:https://playwright.dev/java/[Playwright] is an open source end-to-end testing library developed by Microsoft. Similarly to Selenium, it provides Java API to simulate user interactions in via browsers. Compared to <<end-to-end,TestBench>> it lacks high level API for Vaadin components and it doesn't automatically wait for the client-server communication to stabilize after user interaction.

This guide describes:

. How to set up Playwright to a Spring Boot based Vaadin application;
. The making of a simple Playwright test;
. The basics of finding and interacting with components in a Playwright test

Note, that although these instructions are Spring Boot specific, the same principles can be adapted to other architectures as well. The difference is that you need to control starting and stopping the server in a different manner. For example you can use the `pre-integration-test` and `post-integration-test` phases as done in <<{articles}/end-to-end/getting-started#, Getting Started with End-to-End Testing>>. Also, you can adopt the `@SpringBootTest` based approach described here for selenium<<selenium,Testing with Selenium>>.

== Setting Up Playwright

To use Playwright in a Vaadin application, you need to perform the following steps:

. Add the Playwright dependency to your project's [filename]`pom.xml` file.
+
.`pom.xml`
[source,xml]
----
<dependency>
    <groupId>com.microsoft.playwright</groupId>
    <artifactId>playwright</artifactId>
    <version>1.36.0</version> <!-- Check the latest version via https://playwright.dev -->
</dependency>

----

. Make sure you have `spring-boot-starter-test` module in your project
+
. Spring Boot's test starter module brings in for example JUnit 5 and Spring's own tooling that you use to control starting the server for tests.
+
.`pom.xml`
[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
----
+
. You might already be bringing in this dependency already, don't add a duplicate.


== Create Your First Playwright Test

First you need some view to test. Add or modify your main view to be like this:
+
.`MainView.java``
[source,java]
----
@Route
public class MainView extends VerticalLayout {

    public MainView() {
        var msg = new Paragraph("");
        // Add id to make testing easier
        msg.setId("msg");
 
        Button button = new Button("Click me", e -> {
            msg.setText("Clicked!");
        });

        add(button, msg);
    }
}
----

The above view is the same as generated by vaadin-archetype-spring-application, but also adds an identifier for the added paragraph. Adding identifiers to components generally helps writing and maintaining end-to-end tests.

Next, add a following Java class to your test directory (for example `srs/test/java/org/example/`), that tests the `MainView` works properly.
+
.`TrivialPlaywrightTest.java`
[source,java]
----
package org.example;

import com.microsoft.playwright.Browser;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;

import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) // <1>
@Tag("playwright") // <2>
public class TrivialPlaywrightTest {

    // This will be injected with the random free port
    // number that was allocated
    @LocalServerPort // <3>
    private int port;

    static Playwright playwright = Playwright.create(); // <4>

    @Test
    public void testClicking() {
        Browser browser = playwright.chromium().launch(); // <5>
        Page page = browser.newPage();
        page.navigate("http://localhost:" + port + "/");

        assertThat(page.getByText("Click me")).isVisible(); // <6>

        page.locator("//vaadin-button[contains(text(),'Click me')]").click(); // <7>

        assertThat(page.locator("#msg")).containsText("Clicked!"); // <8>

    }
}
----
<1> Instructs Spring Boot to instantiate a full context with web server before running this test. Random port for web server is used, so that you can keep a development server running and it doesn't disturb executing end-to-end tests.
<2> End-to-end tests may be slow to execute. It is be good idea to tag them with standard JUnit 5 annotation, so that you can easily included/exclude them as you wish.
<3> Inject the random port to a variable, so that it is available for tests
<4> Playwright environment initialization only needs to be executed once.
<5> Launch a new Chromium browser, open a page and navigate it to the local port where Spring Boot started the application
<6> Playwright's assert methods, do "implicit wait" automatically. When Playwright gets to the "Click Me" text locator, the element is probably not there yet as loading of the single-page Vaadin web app takes some milliseconds. The assertion still passes as Playwrigh will wait for a while for the text to be present.
<7> There are number of different locators available via the page object. Here using XPath selector that checks for both element name and that it contains the text "Click me". On locators, we can simulate user actions, here a simple mouse click.
<8> Asserts that there is an element with id "msg" in the page that contains text "Clicked!". If we would here simply get the text using `page.locator("#msg").textContent()` and assert using standard JUnit API, it might fail as the server round-trip response might not yet be completed. Again, using the assertion method from Playwright helpers gives a bit of time for the SPA to render the response. Alternatively you could add for example `page.getByText("Clicked!").waitFor();` line before the assertion, to ensure the server round-trip has been completed.


== Running the Tests

As the test is annotated with the JUnit 5 @Test annotation, the most natural way to run it is via your IDE. Also, the test will be picked up by convention if you call:
+
[source,terminal]
----
mvn test
----

If you had previously written some unit tests to your project, you probably noticed that excution time went up couple of seconds. This is natural as a full server is started and Playwright launches a browser to execute the test. You can use standard JUnit 5 and Maven features to include or exclude the tests. As we added the `playwright` tag to the test, we can execute only the fast unit tests by executing:
+
[source,terminal]
----
mvn test -DexcludedGroups="playwright"
----

== More about Playwright

For more information about using Playwright, check out:

 * link:https://playwright.dev/java/[Official Playwright Java documentation]
 * link:https://www.lumme.dev/2021/04/15/using-playwright-and-junit.html/[Vaadin & Playwright blog post by Erik Lumme]
 * link:https://martinelli.ch/ui-testing-with-vaadin-and-playwright/[Vaadin & Playwright blog post by Simon Martinelli]

[discussion-id]`A8496E86-4D72-11EE-BE56-0242AC120002`
